/*
    LiveURLs - a Firefox extension that lets you create links to
    specific content on web pages

    Copyright (C) <2006>  Infosys Technologies Ltd.
    Authors : Natarajan Kannan (Natarajan_Kannan@infosys.com)
              Toufeeq Hussain (Toufeeq_Hussain@infosys.com)

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

var commonUtils = {

    /* delimiter used to separate parameters in fragment ID, using '+'
     * has advantages.  It does not change on url-encoding, no other
     * part of the fragment ID generated by liveurls will have a +
     * except for the start string to identify which we use the length
     * and not the delimiter.
     */
    delim : "+",
    
    /* these characters are not used while calculating the checksum */
    unWantedChars: /[\n\t\r\ \~\`\!\@\#\$\%\^\&\*\(\)\-\+\=\[\]\{\}\:\;\"\'\<\,\>\.\?\/\\\|]+/g,

    /* common utility functions used by both "Search" and "DOM" based
     * approaches 
     */

    /* does nothing */
    cleanStrings: function(str)
    {
        /* we remove a pre-determined set of unwanted characters from
         * the text nodes that we consider
         */

        str = str.replace(this.unWantedChars, "");
        return str;
    },

    /* Adds a given range to the current window selection */
    selectRange: function(range)
    {
        var selection = 
            this.getTabOfDocument().contentWindow.getSelection();
        if(selection.rangeCount > 0)
            selection.removeAllRanges();
        selection.addRange(range);
    },

    /* Displays only the given range, stripping out all the other DOM nodes */
    displayRange: function(range)
    {
        var fragment = range.cloneContents();
        var body =
            content.document.getElementsByTagName("body").item(0);

        body.parentNode.replaceChild(fragment, body);
    },

    /* To test if a DOM node is a true TEXT node */
    isTextNode: function(aNode) 
    {
        return ((aNode.nodeType == aNode.TEXT_NODE)
        && (aNode.nodeType != aNode.CDATA_SECTION_NODE)
        && (aNode.nodeType != aNode.PROCESSING_INSTRUCTION_NODE));
    },

    /* To test if a DOM node is a TEXT type node */
    isTextTypeNode: function(aNode) 
    {
        return ((aNode.nodeType == aNode.TEXT_NODE)
            || (aNode.nodeType == aNode.CDATA_SECTION_NODE)
            || (aNode.nodeType == aNode.PROCESSING_INSTRUCTION_NODE));
    },

    /* debugging function, see output in Javascript Console window of
     * Firefox
     */
    output: function(text) 
    {
        var consoleService =  
            Components.classes['@mozilla.org/consoleservice;1'].
            getService(Components.interfaces.nsIConsoleService);
        consoleService.logStringMessage(text);
    },
     
    /* Checks for text nodes with only white space characters and
     * rejects them.
     * The following function has been generously re-used from the
     * Scrapbook extension for Firefox
     * http://amb.vis.ne.jp/mozilla/scrapbook/
     */
    acceptNode: function(aNode)
    {
        /* If aNode is a TEXT_NODE and it contains only whitespace
         * characters, we reject it
         */
        if ( aNode.nodeType == aNode.TEXT_NODE
        && ! ( /[^\t\n\r ]/.test( aNode.nodeValue )) 
        ) {
            return NodeFilter.FILTER_REJECT;
        }

        return NodeFilter.FILTER_ACCEPT;
    },

    copyToClipboard: function(liveURL)
    {
        const gClipboardHelper = 
                Components.classes["@mozilla.org/widget/clipboardhelper;1"].
                getService(Components.interfaces.nsIClipboardHelper);
        gClipboardHelper.copyString(liveURL);
    },

    bookmarkURL: function(liveURL)
    {
        var bmsvc = Components.classes["@mozilla.org/browser/nav-bookmarks-service;1"]
                              .getService(Components.interfaces.nsINavBookmarksService);
        var menuFolder = bmsvc.bookmarksMenuFolder; // Bookmarks menu folder

        var aDocShell =
            document.getElementById('content').webNavigation;
        var url = liveURL;
        var title;
        var description;
        try {
            title = aDocShell.document.title || url;
        }
        catch (e) {
            title = url;
        }

        var uri = makeURI(url, null, null);
        try {
            var newBkmkId = bmsvc.insertBookmark(menuFolder, uri, bmsvc.DEFAULT_INDEX, title);
            alert(this.getLocalizedString('context.bookmark-added') + ' ' + url);
        } catch(e) {
        
        }
        return newBkmkId;
    },

    makeURI: function(aURL, aOriginCharset, aBaseURI)
    {
      var ioService = Components.classes["@mozilla.org/network/io-service;1"]  
                                .getService(Components.interfaces.nsIIOService);  
      return ioService.newURI(aURL, aOriginCharset, aBaseURI);  
    },

    getTabOfDocument: function(currentDoc)
    {
        /*
        var index = gBrowser.getBrowserIndexForDocument(currentDoc);
        if(index < 0) {
            return null;
        } else {
            return gBrowser.getBrowserAtIndex(index);
        }
        */
        return gBrowser.getBrowserForDocument(currentDoc);
    },

    isTextSelected: function(currentDoc)
    {
        var currentTab = this.getTabOfDocument(currentDoc);
        var selectionLen = 
            currentTab.contentWindow.getSelection().toString().length;

        return (selectionLen > 0) ? true : false;
    },

    focusLiveText: function(currentDoc, instance)
    {
        var liveNodes = currentDoc.evaluate(
            "//span[@class='livetext']",
            currentDoc,
            null,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null);

        if(liveNodes.snapshotLength > instance) {
            liveNodes.snapshotItem(instance).scrollIntoView();
        }
    },

    isLivePage: function(currentDoc)
    {
        var liveNodes = currentDoc.evaluate(
            "//span[@class='livetext']",
            currentDoc,
            null,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null);

        if(liveNodes.snapshotLength > 0) {
            return true;
        } else {
            return false;
        }
    },

    /* checks if a given range overlaps any of the existing livetext
     * nodes
     */
    isOverlappedSelection: function(currentDoc, range)
    {
        var liveNodes = currentDoc.evaluate(
            "//span[@class='livetext']",
            currentDoc,
            null,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null);

        for(var i = 0; i < liveNodes.snapshotLength; i++) {
            var nRange = document.createRange();
            try {
                nRange.selectNode(liveNodes.snapshotItem(i));
            } catch(e) {
                nRange.selectNodeContents(liveNodes.snapshotItem(i));
            }

            if((range.compareBoundaryPoints(Range.END_TO_START, nRange) == -1) &&
               (range.compareBoundaryPoints(Range.START_TO_END, nRange) == 1)) {
                return true;
            }
        }

        return false;
    },

    getCurrentTab: function()
    {
        return gBrowser.getBrowserAtIndex(gBrowser.mTabContainer.selectedIndex);
    },

    getDocumentOfEvent: function(event)
    {
        var currentDoc;
        if(event.originalTarget instanceof HTMLDocument) {
            if(event.originalTarget.defaultView.frameElement) {
                currentDoc = event.originalTarget;
                while (currentDoc.defaultView.frameElement) {
                    currentDoc =
                        currentDoc.defaultView.frameElement.ownerDocument;
                }
            } else {
                currentDoc = event.originalTarget;
            }
        }

        return currentDoc;
    },

    getLocalizedString: function(str)
    {
        var common = {
          _bundle: Components.classes["@mozilla.org/intl/stringbundle;1"]  
                   .getService(Components.interfaces.nsIStringBundleService)  
                   .createBundle("chrome://webmarker/locale/webmarker.properties"),  
          
           getLocalizedMessage: function(msg) {  
              return this._bundle.GetStringFromName(msg);  
           }  
        };

        return common.getLocalizedMessage(str);
    }
};
